# üìã DETAILED UPDATE PROPOSAL - EA v1.2

## üéØ Summary of Changes

### Core Improvements:
1. **Dynamic Configuration** - T·∫•t c·∫£ settings ƒë∆∞a ra input parameters
2. **Toggle Features** - ON/OFF cho DCA, BE, Trailing, MDD Guard
3. **Trailing Stop** - Implement ATR-based trailing v·ªõi c√°c m·ªëc R-multiple
4. **Risk Scaling** - MaxLot theo % equity thay v√¨ c·ª©ng
5. **Equity-based Guards** - S·ª≠ d·ª•ng equity cho MDD calculation
6. **Confluence Filters** - Optional check structure m·ªõi tr∆∞·ªõc khi DCA

---

## üìÅ FILE 1: `Include/risk_manager.mqh`

### **CHANGE #1: Add Dynamic Configuration Parameters**

**Location:** Sau d√≤ng 20 (private members)

```cpp
// === ADD THESE NEW PARAMETERS ===
private:
    // ... existing members ...
    
    // [NEW] Feature toggles
    bool     m_enableDCA;
    bool     m_enableBE;
    bool     m_enableTrailing;
    bool     m_useDailyMDD;
    bool     m_useEquityMDD;      // Use equity instead of balance
    
    // [NEW] Dynamic lot sizing
    bool     m_useEquityBasedLot;
    double   m_maxLotPctEquity;   // % of equity for max lot
    
    // [NEW] Trailing parameters
    double   m_trailStartR;        // Start trailing at +XR
    double   m_trailStepR;         // Move SL every +XR
    double   m_trailATRMult;       // Trail distance = ATR √ó mult
    
    // [NEW] DCA confluence filter
    bool     m_dcaRequireConfluence;
    bool     m_dcaCheckEquity;
    double   m_dcaMinEquityPct;   // Min equity % vs start balance
```

---

### **CHANGE #2: Update Init() Function**

**Location:** Replace lines 72-85 (existing Init function)

```cpp
// === REPLACE EXISTING Init() ===
bool CRiskManager::Init(string symbol, 
                        double riskPct, double maxLot, int maxDCA, double dailyMDD,
                        // [NEW] Add these parameters
                        bool enableDCA, bool enableBE, bool enableTrailing, 
                        bool useDailyMDD, bool useEquityMDD,
                        bool useEquityBasedLot, double maxLotPctEquity,
                        double trailStartR, double trailStepR, double trailATRMult,
                        bool dcaRequireConfluence, bool dcaCheckEquity, double dcaMinEquityPct) {
    
    m_symbol = symbol;
    m_riskPerTradePct = riskPct;
    m_maxLotPerSide = maxLot;
    m_maxDcaAddons = maxDCA;
    m_dailyMddMax = dailyMDD;
    
    // [NEW] Feature toggles
    m_enableDCA = enableDCA;
    m_enableBE = enableBE;
    m_enableTrailing = enableTrailing;
    m_useDailyMDD = useDailyMDD;
    m_useEquityMDD = useEquityMDD;
    
    // [NEW] Dynamic lot sizing
    m_useEquityBasedLot = useEquityBasedLot;
    m_maxLotPctEquity = maxLotPctEquity;
    
    // [NEW] Trailing parameters
    m_trailStartR = trailStartR;
    m_trailStepR = trailStepR;
    m_trailATRMult = trailATRMult;
    
    // [NEW] DCA filters
    m_dcaRequireConfluence = dcaRequireConfluence;
    m_dcaCheckEquity = dcaCheckEquity;
    m_dcaMinEquityPct = dcaMinEquityPct;
    
    ResetDailyTracking();
    return true;
}
```

---

### **CHANGE #3: Update CalcLotsByRisk - Dynamic MaxLot**

**Location:** Replace lines 105-130 (existing CalcLotsByRisk)

```cpp
// === REPLACE ENTIRE FUNCTION ===
double CRiskManager::CalcLotsByRisk(double riskPct, double slPoints) {
    // [CHANGE] Use equity instead of balance for more accuracy
    double equity = GetCurrentEquity();
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double baseValue = m_useEquityMDD ? equity : balance;
    
    double riskValue = baseValue * (riskPct / 100.0);
    
    // Get tick value
    double tickValue = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_TICK_VALUE);
    double tickSize = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_TICK_SIZE);
    
    if(tickSize == 0 || slPoints == 0) return 0.01;
    
    // Calculate value per point per lot
    double valuePerPointPerLot = tickValue * (_Point / tickSize);
    
    // Calculate lots
    double lots = riskValue / (slPoints * valuePerPointPerLot);
    
    // Normalize
    lots = NormalizeDouble(lots, 2);
    
    // Apply min/max limits
    double minLot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MAX);
    
    if(lots < minLot) lots = minLot;
    if(lots > maxLot) lots = maxLot;
    
    // [NEW] Dynamic max lot based on equity
    double effectiveMaxLot = m_maxLotPerSide;
    if(m_useEquityBasedLot) {
        double tickValuePerLot = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_TICK_VALUE);
        double contractSize = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_CONTRACT_SIZE);
        double currentPrice = (SymbolInfoDouble(m_symbol, SYMBOL_BID) + 
                              SymbolInfoDouble(m_symbol, SYMBOL_ASK)) / 2.0;
        
        double maxExposure = equity * (m_maxLotPctEquity / 100.0);
        effectiveMaxLot = maxExposure / (contractSize * currentPrice / 100.0); // Adjust for XAU
        effectiveMaxLot = NormalizeDouble(effectiveMaxLot, 2);
        
        // Use minimum of static and dynamic
        effectiveMaxLot = MathMin(effectiveMaxLot, m_maxLotPerSide);
    }
    
    if(lots > effectiveMaxLot) lots = effectiveMaxLot;
    
    return lots;
}
```

---

### **CHANGE #4: Update CheckDailyMDD - Use Equity Option**

**Location:** Replace lines 155-195 (existing CheckDailyMDD)

```cpp
// === REPLACE ENTIRE FUNCTION ===
bool CRiskManager::CheckDailyMDD() {
    // [NEW] Can be disabled
    if(!m_useDailyMDD) return true;
    
    ResetDailyTracking(); // Check if new day
    
    if(m_tradingHalted) return false;
    
    // [CHANGE] Use equity or balance based on setting
    double current = m_useEquityMDD ? GetCurrentEquity() : AccountInfoDouble(ACCOUNT_BALANCE);
    double start = m_useEquityMDD ? m_startDayBalance : m_startDayBalance;
    
    double dailyPL = ((current - start) / start) * 100.0;
    
    if(dailyPL <= -m_dailyMddMax) {
        Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        Print("‚ö†Ô∏è DAILY MDD EXCEEDED: ", DoubleToString(dailyPL, 2), "%");
        Print("   Start: $", DoubleToString(start, 2));
        Print("   Current: $", DoubleToString(current, 2));
        Print("   Loss: $", DoubleToString(current - start, 2));
        Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        Print("üõë CLOSING ALL POSITIONS AND HALTING TRADING");
        Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        
        m_tradingHalted = true;
        
        // Close all positions
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket)) {
                if(PositionGetString(POSITION_SYMBOL) == m_symbol) {
                    MqlTradeRequest request;
                    MqlTradeResult result;
                    ZeroMemory(request);
                    ZeroMemory(result);
                    
                    request.action = TRADE_ACTION_DEAL;
                    request.position = ticket;
                    request.symbol = m_symbol;
                    request.volume = PositionGetDouble(POSITION_VOLUME);
                    request.deviation = 20;
                    
                    if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
                        request.type = ORDER_TYPE_SELL;
                        request.price = SymbolInfoDouble(m_symbol, SYMBOL_BID);
                    } else {
                        request.type = ORDER_TYPE_BUY;
                        request.price = SymbolInfoDouble(m_symbol, SYMBOL_ASK);
                    }
                    
                    if(!OrderSend(request, result)) {
                        Print("‚ùå Failed to close position on MDD: ", result.retcode);
                    } else {
                        Print("‚úÖ Closed position #", ticket);
                    }
                }
            }
        }
        
        return false;
    }
    
    return true;
}
```

---

### **CHANGE #5: Add New Trailing Stop Functions**

**Location:** Add BEFORE ManageOpenPositions() (around line 250)

```cpp
// === ADD THESE NEW FUNCTIONS ===

//+------------------------------------------------------------------+
//| Get ATR value for trailing calculation                          |
//+------------------------------------------------------------------+
double CRiskManager::GetATR() {
    int atrHandle = iATR(m_symbol, PERIOD_CURRENT, 14);
    if(atrHandle == INVALID_HANDLE) return 0;
    
    double atr[];
    ArraySetAsSeries(atr, true);
    if(CopyBuffer(atrHandle, 0, 0, 2, atr) > 0) {
        IndicatorRelease(atrHandle);
        return atr[0];
    }
    
    IndicatorRelease(atrHandle);
    return 0;
}

//+------------------------------------------------------------------+
//| Calculate trailing stop level                                    |
//+------------------------------------------------------------------+
double CRiskManager::CalcTrailLevel(ulong ticket, double profitR) {
    if(!PositionSelectByTicket(ticket)) return 0;
    
    double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentSL = PositionGetDouble(POSITION_SL);
    int posType = (int)PositionGetInteger(POSITION_TYPE);
    
    double atr = GetATR();
    if(atr == 0) return currentSL; // Keep current if can't get ATR
    
    double trailDistance = atr * m_trailATRMult;
    double newSL = currentSL;
    
    if(posType == POSITION_TYPE_BUY) {
        // Trail up: newSL = currentPrice - trailDistance
        double candidateSL = currentPrice - trailDistance;
        if(candidateSL > currentSL) {
            newSL = candidateSL;
        }
    } else {
        // Trail down: newSL = currentPrice + trailDistance
        double candidateSL = currentPrice + trailDistance;
        if(candidateSL < currentSL) {
            newSL = candidateSL;
        }
    }
    
    return NormalizeDouble(newSL, _Digits);
}

//+------------------------------------------------------------------+
//| Move SL using trailing logic                                     |
//+------------------------------------------------------------------+
bool CRiskManager::TrailSL(ulong ticket) {
    if(!PositionSelectByTicket(ticket)) return false;
    
    double profitR = CalcProfitInR(ticket);
    
    // Only trail if profit >= trail start level
    if(profitR < m_trailStartR) return false;
    
    double newSL = CalcTrailLevel(ticket, profitR);
    double currentSL = PositionGetDouble(POSITION_SL);
    double tp = PositionGetDouble(POSITION_TP);
    int posType = (int)PositionGetInteger(POSITION_TYPE);
    
    // Check if newSL is better than current
    bool shouldUpdate = false;
    if(posType == POSITION_TYPE_BUY && newSL > currentSL) {
        shouldUpdate = true;
    } else if(posType == POSITION_TYPE_SELL && newSL < currentSL) {
        shouldUpdate = true;
    }
    
    if(!shouldUpdate) return false;
    
    MqlTradeRequest request;
    MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);
    
    request.action = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol = m_symbol;
    request.sl = newSL;
    request.tp = tp;
    
    if(OrderSend(request, result)) {
        double pointsMoved = MathAbs(newSL - currentSL) / _Point;
        Print("üìà Trailing SL: #", ticket, 
              " | New SL: ", newSL, 
              " | Moved: ", (int)pointsMoved, " pts",
              " | Profit: ", DoubleToString(profitR, 2), "R");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Check if should add DCA based on confluence                      |
//+------------------------------------------------------------------+
bool CRiskManager::CheckDCAConfluence(int direction) {
    // [NEW] Optional confluence check
    if(!m_dcaRequireConfluence) return true; // Skip check if disabled
    
    // TODO: Hook into detector to check for new BOS/FVG/OB
    // For now, return true (will be implemented in integration)
    // This requires passing detector instance to RiskManager
    
    return true; // Placeholder
}

//+------------------------------------------------------------------+
//| Check equity health before DCA                                   |
//+------------------------------------------------------------------+
bool CRiskManager::CheckEquityHealth() {
    if(!m_dcaCheckEquity) return true; // Skip if disabled
    
    double currentEquity = GetCurrentEquity();
    double minEquity = m_startDayBalance * (m_dcaMinEquityPct / 100.0);
    
    if(currentEquity < minEquity) {
        Print("‚ö†Ô∏è DCA Blocked: Equity $", DoubleToString(currentEquity, 2),
              " < ", DoubleToString(m_dcaMinEquityPct, 0), "% of start ($", 
              DoubleToString(minEquity, 2), ")");
        return false;
    }
    
    return true;
}
```

---

### **CHANGE #6: Update ManageOpenPositions - Add Trailing & Filters**

**Location:** Replace lines 265-335 (existing ManageOpenPositions)

```cpp
// === REPLACE ENTIRE FUNCTION ===
void CRiskManager::ManageOpenPositions() {
    // Check daily MDD first
    if(!CheckDailyMDD()) return;
    
    // Update position tracking
    for(int i = ArraySize(m_positions) - 1; i >= 0; i--) {
        ulong ticket = m_positions[i].ticket;
        
        // Check if position still exists
        if(!PositionSelectByTicket(ticket)) {
            ArrayRemove(m_positions, i, 1);
            continue;
        }
        
        // Calculate profit in R
        double profitR = CalcProfitInR(ticket);
        int posType = (int)PositionGetInteger(POSITION_TYPE);
        int direction = (posType == POSITION_TYPE_BUY) ? 1 : -1;
        
        // === [NEW] TRAILING STOP (Always active if enabled) ===
        if(m_enableTrailing) {
            if(profitR >= m_trailStartR) {
                // Check if should move SL based on step
                double lastTrailR = m_positions[i].lastTrailR; // Add this to struct
                if(profitR >= lastTrailR + m_trailStepR) {
                    if(TrailSL(ticket)) {
                        m_positions[i].lastTrailR = profitR;
                    }
                }
            }
        }
        
        // === BREAKEVEN (if enabled) ===
        if(m_enableBE) {
            if(profitR >= m_beLevel_R && !m_positions[i].movedToBE) {
                if(MoveSLToBE(ticket)) {
                    m_positions[i].movedToBE = true;
                    Print("üéØ Breakeven: #", ticket, " at +", DoubleToString(profitR, 2), "R");
                }
            }
        }
        
        // === DCA (if enabled) ===
        if(m_enableDCA) {
            // [NEW] Check equity health before DCA
            if(!CheckEquityHealth()) continue;
            
            // [NEW] Check confluence if required
            if(!CheckDCAConfluence(direction)) continue;
            
            // DCA Add-on #1 at configured level
            if(profitR >= m_dcaLevel1_R && !m_positions[i].dca1Added && 
               m_positions[i].dcaCount < m_maxDcaAddons) {
                
                double addLots = m_positions[i].originalLot * m_dcaSize1_Mult;
                double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
                
                // Check total lot limit
                if(GetSideLots(direction) + addLots <= GetEffectiveMaxLot()) {
                    if(AddDCAPosition(direction, addLots, currentPrice)) {
                        m_positions[i].dca1Added = true;
                        m_positions[i].dcaCount++;
                        Print("‚ûï DCA #1: ", addLots, " lots at +", 
                              DoubleToString(profitR, 2), "R");
                    }
                }
            }
            
            // DCA Add-on #2 at configured level
            if(profitR >= m_dcaLevel2_R && !m_positions[i].dca2Added && 
               m_positions[i].dcaCount < m_maxDcaAddons) {
                
                double addLots = m_positions[i].originalLot * m_dcaSize2_Mult;
                double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
                
                if(GetSideLots(direction) + addLots <= GetEffectiveMaxLot()) {
                    if(AddDCAPosition(direction, addLots, currentPrice)) {
                        m_positions[i].dca2Added = true;
                        m_positions[i].dcaCount++;
                        Print("‚ûï DCA #2: ", addLots, " lots at +", 
                              DoubleToString(profitR, 2), "R");
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Get effective max lot (dynamic or static)                        |
//+------------------------------------------------------------------+
double CRiskManager::GetEffectiveMaxLot() {
    if(!m_useEquityBasedLot) return m_maxLotPerSide;
    
    double equity = GetCurrentEquity();
    double tickValuePerLot = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_TICK_VALUE);
    double contractSize = SymbolInfoDouble(m_symbol, SYMBOL_TRADE_CONTRACT_SIZE);
    double currentPrice = (SymbolInfoDouble(m_symbol, SYMBOL_BID) + 
                          SymbolInfoDouble(m_symbol, SYMBOL_ASK)) / 2.0;
    
    double maxExposure = equity * (m_maxLotPctEquity / 100.0);
    double dynamicMax = maxExposure / (contractSize * currentPrice / 100.0);
    dynamicMax = NormalizeDouble(dynamicMax, 2);
    
    return MathMin(dynamicMax, m_maxLotPerSide);
}
```

---

### **CHANGE #7: Update PositionDCA Struct**

**Location:** Replace lines 35-45 (existing struct)

```cpp
// === REPLACE STRUCT ===
struct PositionDCA {
    ulong    ticket;
    double   entryPrice;
    double   sl;
    double   tp;
    double   originalLot;
    int      dcaCount;
    bool     movedToBE;
    bool     dca1Added;
    bool     dca2Added;
    double   lastTrailR;    // [NEW] Track last trail level to avoid too frequent updates
};
```

---

## üìÅ FILE 2: `Experts/SMC_ICT_EA.mq5`

### **CHANGE #8: Add New Input Parameters**

**Location:** After line 80 (after existing inputs)

```cpp
//+------------------------------------------------------------------+
//| [NEW] Input Parameters - Feature Toggles                        |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Feature Toggles ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool     InpEnableDCA       = true;    // Enable DCA (Pyramiding)
input bool     InpEnableBE        = true;    // Enable Breakeven
input bool     InpEnableTrailing  = true;    // Enable Trailing Stop
input bool     InpUseDailyMDD     = true;    // Enable Daily MDD Guard
input bool     InpUseEquityMDD    = true;    // Use Equity for MDD (vs Balance)

//+------------------------------------------------------------------+
//| [NEW] Input Parameters - Dynamic Lot Sizing                     |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Dynamic Lot Sizing ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool     InpUseEquityBasedLot = false; // Use % Equity for MaxLot
input double   InpMaxLotPctEquity   = 10.0;  // Max lot as % of equity (if enabled)

//+------------------------------------------------------------------+
//| [NEW] Input Parameters - Trailing Stop                          |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Trailing Stop ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input double   InpTrailStartR     = 1.0;     // Start trailing at +XR
input double   InpTrailStepR      = 0.5;     // Move SL every +XR
input double   InpTrailATRMult    = 2.0;     // Trail distance (ATR multiple)

//+------------------------------------------------------------------+
//| [NEW] Input Parameters - DCA Filters                            |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê DCA Filters ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool     InpDcaRequireConfluence = false; // Require new BOS/FVG before DCA
input bool     InpDcaCheckEquity       = true;  // Check equity health before DCA
input double   InpDcaMinEquityPct      = 95.0;  // Min equity % vs start balance

//+------------------------------------------------------------------+
//| [NEW] Input Parameters - DCA Levels (moved from hardcoded)     |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê DCA Levels ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input double   InpDcaLevel1_R     = 0.75;    // First DCA trigger (+XR)
input double   InpDcaLevel2_R     = 1.5;     // Second DCA trigger (+XR)
input double   InpDcaSize1_Mult   = 0.5;     // First DCA size (√ó original)
input double   InpDcaSize2_Mult   = 0.33;    // Second DCA size (√ó original)
input double   InpBeLevel_R       = 1.0;     // Breakeven trigger (+XR)
```

---

### **CHANGE #9: Update RiskManager Init Call**

**Location:** Replace lines 115-120 (in OnInit, g_riskMgr initialization)

```cpp
// === REPLACE THIS BLOCK ===
g_riskMgr = new CRiskManager();
if(!g_riskMgr.Init(_Symbol, 
                   InpRiskPerTradePct, InpMaxLotPerSide, InpMaxDcaAddons, InpDailyMddMax,
                   // [NEW] Add all new parameters
                   InpEnableDCA, InpEnableBE, InpEnableTrailing,
                   InpUseDailyMDD, InpUseEquityMDD,
                   InpUseEquityBasedLot, InpMaxLotPctEquity,
                   InpTrailStartR, InpTrailStepR, InpTrailATRMult,
                   InpDcaRequireConfluence, InpDcaCheckEquity, InpDcaMinEquityPct)) {
    Print("ERROR: Failed to initialize risk manager");
    return INIT_FAILED;
}

// [NEW] Set DCA levels after init
g_riskMgr.SetDCALevels(InpDcaLevel1_R, InpDcaLevel2_R, 
                       InpDcaSize1_Mult, InpDcaSize2_Mult,
                       InpBeLevel_R);
```

---

### **CHANGE #10: Add DCA Levels Setter to RiskManager**

**Location:** Add to risk_manager.mqh (public methods section, around line 60)

```cpp
// === ADD THIS METHOD TO CRiskManager CLASS ===
void SetDCALevels(double level1R, double level2R, 
                  double size1Mult, double size2Mult,
                  double beLevel) {
    m_dcaLevel1_R = level1R;
    m_dcaLevel2_R = level2R;
    m_dcaSize1_Mult = size1Mult;
    m_dcaSize2_Mult = size2Mult;
    m_beLevel_R = beLevel;
}
```

---

## üìÅ FILE 3: `Include/executor.mqh`

### **CHANGE #11: Update SpreadOK - Dynamic Spread Filter**

**Location:** Replace lines 85-95 (existing SpreadOK function)

```cpp
// === REPLACE ENTIRE FUNCTION ===
bool CExecutor::SpreadOK() {
    long spread = SymbolInfoInteger(m_symbol, SYMBOL_SPREAD);
    double atr = GetATR();
    
    // [NEW] Dynamic spread filter: accept up to max(fixed threshold, 8% of ATR)
    if(atr > 0) {
        long dynamicMax = (long)MathMax(m_spreadMaxPts, 0.08 * atr / _Point);
        
        if(spread > dynamicMax) {
            Print("‚ö†Ô∏è Spread too wide: ", spread, " pts (max: ", dynamicMax, " pts)");
            return false;
        }
        return true;
    }
    
    // Fallback to static if can't get ATR
    if(spread > m_spreadMaxPts) {
        Print("‚ö†Ô∏è Spread too wide: ", spread, " pts (max: ", m_spreadMaxPts, " pts)");
        return false;
    }
    return true;
}
```

---

### **CHANGE #12: Fix SessionOpen - Proper Timezone Handling**

**Location:** Replace lines 70-80 (existing SessionOpen)

```cpp
// === REPLACE ENTIRE FUNCTION ===
bool CExecutor::SessionOpen() {
    MqlDateTime s;
    TimeToStruct(TimeCurrent(), s); // Server time
    
    // [FIX] Calculate proper timezone offset
    // VN_GMT - Server_GMT = delta to apply
    int server_gmt = (int)(TimeGMTOffset() / 3600);
    int vn_gmt = 7;
    int delta = vn_gmt - server_gmt;
    int hour_localvn = (s.hour + delta + 24) % 24;
    
    bool inSession = (hour_localvn >= m_sessStartHour && hour_localvn < m_sessEndHour);
    
    // [DEBUG] Log once per hour for verification
    static int lastLogHour = -1;
    if(s.hour != lastLogHour) {
        Print("üïê Session Check | Server: ", s.hour, ":00 | VN Time: ", hour_localvn, 
              ":00 | Status: ", inSession ? "IN SESSION ‚úÖ" : "CLOSED ‚ùå");
        lastLogHour = s.hour;
    }
    
    return inSession;
}
```

---

### **CHANGE #13: Relax Trigger Candle Requirements**

**Location:** Replace lines 125-155 (GetTriggerCandle function)

```cpp
// === REPLACE ENTIRE FUNCTION ===
bool CExecutor::GetTriggerCandle(int direction, double &triggerHigh, double &triggerLow) {
    double atr = GetATR();
    if(atr <= 0) return false;
    
    // [CHANGE] Lower threshold: 25% of ATR or minimum 30 points (3 pips)
    double minBodySize = MathMax((m_triggerBodyATR / 100.0) * atr, 30.0 * _Point);
    
    // [CHANGE] Scan bars 0-3 instead of just 0-1
    for(int i = 0; i <= 3; i++) {
        double open = iOpen(m_symbol, m_timeframe, i);
        double close = iClose(m_symbol, m_timeframe, i);
        double high = iHigh(m_symbol, m_timeframe, i);
        double low = iLow(m_symbol, m_timeframe, i);
        double bodySize = MathAbs(close - open);
        
        if(bodySize >= minBodySize) {
            // For sell setup, need bearish trigger
            if(direction == -1 && close < open) {
                triggerHigh = high;
                triggerLow = low;
                Print("üéØ Trigger SELL: Bar ", i, " | Body: ", (int)(bodySize/_Point), 
                      " pts (min: ", (int)(minBodySize/_Point), " pts)");
                return true;
            }
            // For buy setup, need bullish trigger
            else if(direction == 1 && close > open) {
                triggerHigh = high;
                triggerLow = low;
                Print("üéØ Trigger BUY: Bar ", i, " | Body: ", (int)(bodySize/_Point), 
                      " pts (min: ", (int)(minBodySize/_Point), " pts)");
                return true;
            }
        }
    }
    
    Print("‚ùå No trigger candle found (scanned bars 0-3)");
    return false;
}
```

---

### **CHANGE #14: Relax SL Minimum Constraint**

**Location:** Replace lines 165-230 (CalculateEntry function)

```cpp
// === FIND AND REPLACE THESE SECTIONS ===

// Around line 185 (BUY setup SL calculation)
// [BEFORE]
// double slDistance = entry - sl;
// if(slDistance < minStopDistance) {
//     sl = entry - minStopDistance;
// }
// if(slDistance < atr) {  // ‚Üê REMOVE THIS
//     sl = entry - atr;     // ‚Üê REMOVE THIS
// }                         // ‚Üê REMOVE THIS

// [AFTER - Replace with:]
double slDistance = entry - sl;
double minStopDistance = m_minStopPts * _Point;

// [CHANGE] Only enforce minStop, don't force >= ATR
if(slDistance < minStopDistance) {
    sl = entry - minStopDistance;
    Print("‚ö†Ô∏è SL adjusted to minStop: ", (int)minStopDistance/_Point, " pts");
}

// Around line 210 (SELL setup SL calculation)
// [BEFORE]
// double slDistance = sl - entry;
// if(slDistance < minStopDistance) {
//     sl = entry + minStopDistance;
// }
// if(slDistance < atr) {  // ‚Üê REMOVE THIS
//     sl = entry + atr;     // ‚Üê REMOVE THIS
// }                         // ‚Üê REMOVE THIS

// [AFTER - Replace with:]
double slDistance = sl - entry;
double minStopDistance = m_minStopPts * _Point;

// [CHANGE] Only enforce minStop, don't force >= ATR
if(slDistance < minStopDistance) {
    sl = entry + minStopDistance;
    Print("‚ö†Ô∏è SL adjusted to minStop: ", (int)minStopDistance/_Point, " pts");
}
```

---

## üìÅ FILE 4: `Include/detectors.mqh`

### **CHANGE #15: Fix Sweep Detection - Scan Multiple Bars**

**Location:** Replace lines 280-350 (DetectSweep function)

```cpp
// === REPLACE THE ENTIRE DetectSweep() FUNCTION ===
SweepSignal CDetector::DetectSweep() {
    SweepSignal sweep;
    sweep.detected = false;
    sweep.valid = false;
    sweep.side = 0;
    sweep.barsAge = 0;
    sweep.ttl = m_sweep_TTL;
    
    if(ArraySize(m_high) < m_lookbackLiq + 4) return sweep;
    
    // Find max high and min low in lookback (starting from bar 4)
    double maxHigh = m_high[4];
    double minLow = m_low[4];
    for(int i = 5; i <= m_lookbackLiq + 4; i++) {
        if(m_high[i] > maxHigh) maxHigh = m_high[i];
        if(m_low[i] < minLow) minLow = m_low[i];
    }
    
    // [CHANGE] Scan bars 0-3 for recent sweep (instead of just bar 0)
    for(int bar = 0; bar <= 3; bar++) {
        double currentHigh = m_high[bar];
        double currentLow = m_low[bar];
        double currentClose = m_close[bar];
        double currentOpen = m_open[bar];
        double candleRange = currentHigh - currentLow;
        
        if(candleRange <= 0) continue;
        
        // Check for buy-side sweep (high sweep)
        double upperWick = currentHigh - MathMax(currentClose, currentOpen);
        double upperWickPct = (upperWick / candleRange) * 100.0;
        
        if(currentHigh > maxHigh && 
           (currentClose <= maxHigh || upperWickPct >= m_minWickPct)) {
            sweep.detected = true;
            sweep.valid = true;
            sweep.side = 1; // buy-side
            sweep.level = currentHigh;
            sweep.time = iTime(m_symbol, m_timeframe, bar);
            
            Print("üíß SWEEP HIGH detected: Bar ", bar, " | Level: ", currentHigh, 
                  " | Wick: ", DoubleToString(upperWickPct, 1), "%");
            return sweep;
        }
        
        // Check for sell-side sweep (low sweep)
        double lowerWick = MathMin(currentClose, currentOpen) - currentLow;
        double lowerWickPct = (lowerWick / candleRange) * 100.0;
        
        if(currentLow < minLow && 
           (currentClose >= minLow || lowerWickPct >= m_minWickPct)) {
            sweep.detected = true;
            sweep.valid = true;
            sweep.side = -1; // sell-side
            sweep.level = currentLow;
            sweep.time = iTime(m_symbol, m_timeframe, bar);
            
            Print("üíß SWEEP LOW detected: Bar ", bar, " | Level: ", currentLow, 
                  " | Wick: ", DoubleToString(lowerWickPct, 1), "%");
            return sweep;
        }
    }
    
    return sweep;
}
```

---

## üìÅ FILE 5: `Include/arbiter.mqh`

### **CHANGE #16: Relax Entry Conditions - Two Paths**

**Location:** Replace lines 120-135 (BuildCandidate validation section)

```cpp
// === FIND THIS SECTION (around line 120-135) ===
// Check BOS
if(bos.valid && bos.direction != 0) {
    c.hasBOS = true;
    c.direction = bos.direction;
} else {
    return c; // Need BOS for valid setup  // ‚Üê REMOVE THIS LINE
}

// [ADD THIS AFTER BOS CHECK]
// If no BOS, allow momentum-based entry
if(!c.hasBOS) {
    if(momo.valid) {
        c.direction = momo.direction;
        c.hasMomo = true;
        Print("üìä Entry via MOMENTUM (no BOS)");
    } else {
        return c; // Need either BOS or Momentum
    }
}

// ... existing sweep check ...

// [CHANGE] At end of function, REPLACE:
// if(!c.hasBOS || !c.hasSweep || (!c.hasOB && !c.hasFVG)) {
//     return c;
// }

// [WITH THIS - Two valid paths:]
// Path A: BOS + (OB or FVG) - no sweep required
bool pathA = c.hasBOS && (c.hasOB || c.hasFVG);

// Path B: Sweep + (OB or FVG) + Momentum (without BOS, but momentum confirms)
bool pathB = c.hasSweep && (c.hasOB || c.hasFVG) && c.hasMomo && !c.momoAgainstSmc;

c.valid = (pathA || pathB);

if(c.valid) {
    string path = pathA ? "Path A (BOS+POI)" : "Path B (Sweep+POI+Momo)";
    Print("‚úÖ Valid Candidate: ", path, " | Direction: ", c.direction == 1 ? "LONG" : "SHORT");
}

return c;
```

---

## üìÅ FILE 6: Create New File `Include/config_presets.mqh`

**Location:** Create NEW file

```cpp
//+------------------------------------------------------------------+
//|                                              config_presets.mqh  |
//|                              Configuration Preset Profiles       |
//+------------------------------------------------------------------+
#property copyright "SMC/ICT EA"
#property version   "1.20"
#property strict

// Pre-defined configuration profiles for different trading styles

//+------------------------------------------------------------------+
//| Preset 1: Conservative (Low Risk)                               |
//+------------------------------------------------------------------+
struct ConservativePreset {
    // Risk
    static double RiskPerTrade() { return 0.2; }
    static double MaxLotPerSide() { return 2.0; }
    static double DailyMDD() { return 5.0; }
    
    // DCA
    static bool EnableDCA() { return false; } // OFF for conservative
    static int MaxDcaAddons() { return 1; }
    static double DcaLevel1() { return 1.0; }
    static double DcaSize1() { return 0.3; }
    
    // Trailing
    static double TrailStartR() { return 0.75; }
    static double TrailStepR() { return 0.25; }
    static double TrailATRMult() { return 2.5; }
};

//+------------------------------------------------------------------+
//| Preset 2: Balanced (Recommended)                                |
//+------------------------------------------------------------------+
struct BalancedPreset {
    // Risk
    static double RiskPerTrade() { return 0.3; }
    static double MaxLotPerSide() { return 3.0; }
    static double DailyMDD() { return 8.0; }
    
    // DCA
    static bool EnableDCA() { return true; }
    static int MaxDcaAddons() { return 2; }
    static double DcaLevel1() { return 0.75; }
    static double DcaLevel2() { return 1.5; }
    static double DcaSize1() { return 0.5; }
    static double DcaSize2() { return 0.33; }
    
    // Trailing
    static double TrailStartR() { return 1.0; }
    static double TrailStepR() { return 0.5; }
    static double TrailATRMult() { return 2.0; }
};

//+------------------------------------------------------------------+
//| Preset 3: Aggressive (High Risk)                                |
//+------------------------------------------------------------------+
struct AggressivePreset {
    // Risk
    static double RiskPerTrade() { return 0.5; }
    static bool UseEquityBasedLot() { return true; }
    static double MaxLotPctEquity() { return 15.0; }
    static double DailyMDD() { return 12.0; }
    
    // DCA
    static bool EnableDCA() { return true; }
    static int MaxDcaAddons() { return 3; }
    static double DcaLevel1() { return 0.5; }
    static double DcaLevel2() { return 1.0; }
    static double DcaLevel3() { return 1.5; }
    static double DcaSize1() { return 0.618; }
    static double DcaSize2() { return 0.382; }
    static double DcaSize3() { return 0.236; }
    
    // Trailing
    static double TrailStartR() { return 0.75; }
    static double TrailStepR() { return 0.3; }
    static double TrailATRMult() { return 1.5; }
};

// Usage in EA: 
// InpRiskPerTradePct = BalancedPreset::RiskPerTrade();
```

---

## üìä CONFIGURATION GUIDE

### Quick Start Settings

#### **Conservative Profile:**
```
InpRiskPerTradePct = 0.2
InpMaxLotPerSide = 2.0
InpDailyMddMax = 5.0
InpEnableDCA = false
InpEnableTrailing = true
InpTrailStartR = 0.75
InpSpreadMaxPts = 500
```

#### **Balanced Profile (Recommended):**
```
InpRiskPerTradePct = 0.3
InpMaxLotPerSide = 3.0
InpDailyMddMax = 8.0
InpEnableDCA = true
InpEnableTrailing = true
InpTrailStartR = 1.0
InpDcaCheckEquity = true
InpDcaMinEquityPct = 95.0
```

#### **Aggressive Profile:**
```
InpRiskPerTradePct = 0.5
InpUseEquityBasedLot = true
InpMaxLotPctEquity = 15.0
InpDailyMddMax = 12.0
InpEnableDCA = true
InpMaxDcaAddons = 3
InpTrailStartR = 0.75
InpTrailStepR = 0.3
```

---

## üß™ TESTING CHECKLIST

### Unit Tests:
- [ ] **Test 1:** Trailing activates at +1R and moves SL correctly
- [ ] **Test 2:** DCA blocked when equity <95% start balance
- [ ] **Test 3:** SessionOpen() calculates VN timezone correctly
- [ ] **Test 4:** SpreadOK() uses dynamic ATR threshold
- [ ] **Test 5:** Sweep detection finds sweeps in bars 0-3
- [ ] **Test 6:** Entry valid with Path A (BOS+OB) without sweep
- [ ] **Test 7:** Entry valid with Path B (Sweep+OB+Momo) without BOS
- [ ] **Test 8:** MaxLot scales with equity when dynamic enabled
- [ ] **Test 9:** MDD uses equity when InpUseEquityMDD = true
- [ ] **Test 10:** All features can be toggled OFF individually

### Integration Tests:
- [ ] **IT 1:** Full trade cycle with DCA ON
- [ ] **IT 2:** Full trade cycle with DCA OFF, only trailing
- [ ] **IT 3:** Hit daily MDD ‚Üí all positions close + halt
- [ ] **IT 4:** Session filter works across rollover (23:00‚Üí08:00)
- [ ] **IT 5:** Multiple positions with different DCA stages

---

## üìù SUMMARY OF CHANGES

### Fixed Issues:
1. ‚úÖ **Timezone bug** - Proper VN GMT+7 calculation
2. ‚úÖ **Spread filter** - Dynamic ATR-based threshold
3. ‚úÖ **Entry conditions** - Relaxed to 2 valid paths
4. ‚úÖ **Trigger candle** - Lowered threshold + scan 0-3 bars
5. ‚úÖ **SL constraint** - Removed ATR enforcement
6. ‚úÖ **Sweep detection** - Scan multiple recent bars
7. ‚úÖ **Position tracking** - Fixed PositionSelectByTicket API

### New Features:
1. ‚úÖ **Trailing Stop** - ATR-based with configurable start/step
2. ‚úÖ **Dynamic MaxLot** - % equity instead of fixed
3. ‚úÖ **Equity MDD** - Option to use equity vs balance
4. ‚úÖ **DCA Guards** - Equity health check + confluence filter
5. ‚úÖ **Feature Toggles** - ON/OFF for DCA/BE/Trail/MDD
6. ‚úÖ **Dynamic Config** - All settings as inputs
7. ‚úÖ **Debug Logging** - Enhanced prints with emojis

### Configuration Flexibility:
- üéõÔ∏è **18 new input parameters**
- üîÑ **3 preset profiles** (Conservative/Balanced/Aggressive)
- ‚öôÔ∏è **All features toggleable** at runtime
- üìä **Dynamic scaling** options for lot size and risk

---

## üöÄ NEXT STEPS

1. **Copy-paste changes** into your files (follow line numbers exactly)
2. **Compile in MetaEditor** - fix any syntax errors
3. **Run Strategy Tester** with Balanced preset first
4. **Monitor prints** to verify trailing/DCA working
5. **Adjust parameters** based on results

**Estimated Implementation Time:** 2-3 hours

**Critical Files Changed:** 6 files (all .mqh + EA main)

**Backward Compatibility:** ‚úÖ YES (old settings work with new defaults)